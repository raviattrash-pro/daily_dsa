class Solution {
    public String minWindow(String s, String t) {
        int[] need = new int[128];  // NEED = basket of required chars
        for (char c : t.toCharArray()) need[c]++;

        int missing = t.length();   // how many chars are still missing
        int l = 0, start = 0, minLen = Integer.MAX_VALUE;

        for (int r = 0; r < s.length(); r++) {
            if (need[s.charAt(r)] > 0) missing--;  // useful char found
            need[s.charAt(r)]--;                   // mark usage

            // window has all chars â†’ shrink from left
            while (missing == 0) {
                if (r - l + 1 < minLen) {
                    minLen = r - l + 1;
                    start = l;
                }
                need[s.charAt(l)]++;
                if (need[s.charAt(l)] > 0) missing++; // lost a needed char
                l++;
            }
        }
        return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
    }
}

Mnemonics to Remember

Think of the 4 steps: NEED â†’ TAKE â†’ SHRINK â†’ SAVE

NEED â†’ Count chars from t in the need[] basket.

TAKE (R expands) â†’ Add chars by moving right pointer r.

If it was needed â†’ decrease missing.

SHRINK (L moves) â†’ When window is valid (missing == 0), move left l to make it smaller.

If we remove a needed char â†’ missing++.

SAVE â†’ Each time window is valid, check & save best length.

ðŸ§  Quick Story to Lock in Memory

Imagine:

Basket of fruits (NEED) you want.

Right hand (R) keeps picking fruits into a bag until basket is complete.

Left hand (L) throws extra fruits out to make the bag lighter.

Every time bag is perfectly balanced, you SAVE it if itâ€™s the smallest bag yet.